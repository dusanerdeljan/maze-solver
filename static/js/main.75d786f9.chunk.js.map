{"version":3,"sources":["models/Graph.js","components/Node.jsx","components/Edge.jsx","mst/Partition.js","mst/Kruskal.js","models/Stack.js","pathfinding/DFS.js","mst/Boruvka.js","mst/PrimJarnik.js","models/Queue.js","pathfinding/BFS.js","pathfinding/Dijkstra.js","pathfinding/AStar.js","pathfinding/BidirectionalSearch.js","components/Canvas.jsx","App.js","serviceWorker.js","index.js"],"names":["Graph","width","height","this","adjacencyMatrix","edges","vertexCount","_buildAdjacencyMatrix","i","push","j","first","second","vertex","weight","firstVertex","secondVertex","Math","floor","random","g","edgeWeight","getRandomEdgeWeight","addEdge","Node","props","state","type","dimension","position","nodeStyle","top","left","backgroundColor","zIndex","style","Component","Edge","horizontalEdgeStyle","textAlign","verticalEdgeStyle","minVertex","min","edge","maxVertex","max","abs","id","Partition","positions","Array","length","parent","size","find","x","y","xRoot","yRoot","union","kruskal","graph","sort","a","b","mst","maze","partition","doesMakeCycle","Stack","stack","item","pop","dfs","startVertex","endVertex","vertexStack","path","edgesExplored","visitedVertices","Set","parentMap","currentVertex","add","getIncidentEdges","forEach","has","empty","current","reverse","boruvka","treeCount","cheapest","firstRoot","secondRoot","PQEntry","primJarnik","treeBounds","priorityQueue","entryMap","Map","set","get","minElement","delete","Queue","queue","shift","bfs","vertexQueue","enqueue","dequeue","HeapEntry","distance","dijkstra","distances","unvisitedNodes","neighbour","newDistance","astar","remainingDistance","firstPosition","getVertexPosition","secondPosition","row","column","manhattanDistance","bidirectionalSearch","startVisited","endVisited","startParent","endParent","startQueue","endQueue","intersect","bfsHelper","hasIntersectingNode","buildPath","visited","Canvas","mazeGenerationFunctions","mazeSolvingFunctions","startPosX","window","innerWidth","startPosY","innerHeight","generatedMaze","mstEdges","nodeDimensions","errorMessage","generateMaze","bind","solveMaze","mazeClickHandler","mazeSizeChanged","updateNodeDimensions","setState","prevState","initState","addEventListener","removeEventListener","buildGraph","_generateButton","disabled","_solveButton","_sizeSlider","_generationSelect","value","setTimeout","slice","edgeStyle","document","getElementById","animation","animationDuration","checkStartEndVertex","_solvingSelect","displayPath","event","testWidth","parseInt","nativeEvent","target","vertexRow","vertexColumn","shiftKey","map","index","pos","key","nodes","className","htmlFor","color","ref","onClick","step","onChange","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.75d786f9.chunk.js","sourcesContent":["/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nexport default class Graph {\r\n    constructor(width, height) {\r\n        this.width = width\r\n        this.height = height\r\n        this.adjacencyMatrix = []\r\n        this.edges = []\r\n        this.vertexCount = this.width * this.height\r\n        this._buildAdjacencyMatrix()\r\n    }\r\n\r\n    _buildAdjacencyMatrix() {\r\n        for (let i=0;i<this.vertexCount;i++) {\r\n            this.adjacencyMatrix.push([])\r\n            for (let j=0;j<this.vertexCount;j++) {\r\n                this.adjacencyMatrix[i].push(0)\r\n            }\r\n        }\r\n    }\r\n\r\n    edgeExists(first, second) {\r\n        if (first < 0 || first >= this.vertexCount || second < 0 || second >= this.vertexCount) {\r\n            return 0\r\n        } else {\r\n            return this.adjacencyMatrix[first][second]\r\n        }\r\n    }\r\n\r\n    getIncidentEdges(vertex) {\r\n        let edges = []\r\n        for (let i = 0; i < this.vertexCount; i++) {\r\n            if (i !== vertex && this.adjacencyMatrix[vertex][i]) {\r\n                edges.push({first: vertex, second: i, weight: this.adjacencyMatrix[vertex][i]})\r\n            }\r\n        }\r\n        return edges\r\n    }\r\n\r\n    hasTopNeighbour(vertex) {\r\n        return ((vertex-this.width) >= 0 && this.adjacencyMatrix[vertex][vertex-this.width] !== 0)\r\n    }\r\n\r\n    addEdge(firstVertex, secondVertex, weight=1) {\r\n        this.adjacencyMatrix[firstVertex][secondVertex] = weight\r\n        this.adjacencyMatrix[secondVertex][firstVertex] = weight\r\n        this.edges.push({first: firstVertex, second: secondVertex, weight: weight})\r\n    }\r\n\r\n    static getRandomEdgeWeight() {\r\n        return 2 + Math.floor(Math.random() * Math.floor(9999))\r\n    }\r\n\r\n    static buildGraph(width, height) {\r\n        let g = new Graph(width, height)\r\n        for (let vertex = 0; vertex < g.height*g.width; vertex++) {\r\n            const edgeWeight = this.getRandomEdgeWeight()\r\n            if (vertex === 0) { // top-left\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n            } else if (vertex === g.width-1) { // top-right\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n            } else if (vertex === g.height*g.width - g.width) { // bottom-left\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n            } else if (vertex === g.width*g.height-1) { // bottom-right\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n            } else if (vertex % g.width === 0) { // left-edge\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n            } else if (vertex % g.width + 1 === g.width) { // right-edge\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n            } else if (vertex < g.width) { // top-edge\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n            } else if (vertex >= (g.width*g.height)-g.width) { // bottom-edge\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n            } else { // center\r\n                g.addEdge(vertex, vertex+1, edgeWeight)\r\n                g.addEdge(vertex, vertex-1, edgeWeight)\r\n                g.addEdge(vertex, vertex-g.width, edgeWeight)\r\n                g.addEdge(vertex, vertex+g.width, edgeWeight)\r\n            }\r\n        }\r\n        return g\r\n    }\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport React, { Component } from 'react'\r\nimport './Node.css'\r\n\r\nexport class Node extends Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {}\r\n    }\r\n\r\n    render() {\r\n        const {type, dimension, position} = this.props\r\n\r\n        const nodeStyle = {\r\n            position: \"absolute\", \r\n            top: position.top, \r\n            left: position.left,\r\n            width: dimension, \r\n            height: dimension,\r\n            backgroundColor : type === \"start\" ? \"#139b08\" : \"#e3110d\",\r\n            zIndex: 650\r\n        }\r\n\r\n        return (\r\n            <div style={nodeStyle}></div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Node\r\n","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport React, { Component } from 'react'\r\nimport './Edge.css'\r\n\r\nexport class Edge extends Component {\r\n    render() {\r\n        const horizontalEdgeStyle = {\r\n            position: \"absolute\",\r\n            top: this.props.position.top,\r\n            left: this.props.position.left,\r\n            width: 3*this.props.dimension,\r\n            height: this.props.dimension,\r\n            backgroundColor: \"white\",\r\n            textAlign: \"center\"\r\n        }\r\n        const verticalEdgeStyle = {\r\n            position: \"absolute\",\r\n            top: this.props.position.top,\r\n            left: this.props.position.left,\r\n            width: this.props.dimension,\r\n            height: 3*this.props.dimension,\r\n            backgroundColor: \"white\",\r\n            textAlign: \"center\"\r\n        }\r\n        const minVertex = Math.min(this.props.edge.first, this.props.edge.second)\r\n        const maxVertex = Math.max(this.props.edge.first, this.props.edge.second)\r\n        if (Math.abs(this.props.edge.first - this.props.edge.second) === 1) {\r\n            return <div id={`edge-${minVertex}-${maxVertex}`} style={horizontalEdgeStyle}></div>\r\n        } else {\r\n            return <div id={`edge-${minVertex}-${maxVertex}`} style={verticalEdgeStyle}></div>\r\n        }\r\n    }\r\n}\r\n\r\nexport default Edge\r\n","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nexport default class Partition {\r\n    constructor(vertexCount) {\r\n        this.positions = new Array(vertexCount)\r\n        for (let i = 0; i < this.positions.length; i++) {\r\n            this.positions[i] = {parent: i, size: 1}\r\n        }\r\n    }\r\n\r\n    find(vertex) {\r\n        if (this.positions[vertex].parent !== vertex)\r\n            this.positions[vertex].parent = this.find(this.positions[vertex].parent)\r\n        return this.positions[vertex].parent\r\n    }\r\n\r\n    union(x, y) {\r\n        const xRoot = this.find(x)\r\n        const yRoot = this.find(y)\r\n        if (this.positions[xRoot].size < this.positions[yRoot].size)\r\n\t\t    this.positions[xRoot].parent = yRoot;\r\n\t    else if (this.positions[xRoot].size > this.positions[yRoot].size)\r\n\t\t    this.positions[yRoot].parent = xRoot;\r\n        else\r\n        {\r\n            this.positions[yRoot].parent = xRoot;\r\n            this.positions[xRoot].size++;\r\n        }\r\n    }\r\n\r\n    doesMakeCycle(edge) {\r\n        return (this.find(edge.first) === this.find(edge.second))\r\n    }\r\n\r\n    addEdge(edge) {\r\n        this.union(this.find(edge.first), this.find(edge.second))\r\n    }\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Partition from './Partition'\r\nimport Graph from '../models/Graph'\r\n\r\nexport default function kruskal(graph) {\r\n    const edges = [...graph.edges].sort((a, b) => a.weight - b.weight)\r\n    let mst = []\r\n    let maze = new Graph(graph.width, graph.height)\r\n    const vertexCount = graph.width * graph.height\r\n    let partition = new Partition(vertexCount)\r\n    let i = 0\r\n    while (mst.length < vertexCount-1 && i < graph.edges.length) {\r\n        const edge = edges[i]\r\n        if (!partition.doesMakeCycle(edge)) {\r\n            mst.push(edge)\r\n            partition.addEdge(edge)\r\n            maze.addEdge(edge.first, edge.second)\r\n        }\r\n        i++\r\n    }\r\n    return {mst: mst, maze: maze}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nexport default class Stack {\r\n    constructor() {\r\n        this.stack = []\r\n    }\r\n\r\n    empty() {\r\n        return this.stack.length === 0\r\n    }\r\n\r\n    push(item) {\r\n        this.stack.push(item)\r\n    }\r\n\r\n    pop() {\r\n        return this.stack.pop()\r\n    }\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Stack from '../models/Stack'\r\n\r\nexport default function dfs(graph, startVertex, endVertex) {\r\n    let vertexStack = new Stack()\r\n    let path = []\r\n    let edgesExplored = []\r\n    let visitedVertices = new Set()\r\n    vertexStack.push(startVertex)\r\n    let parentMap = new Array(graph.vertexCount)\r\n    while (!vertexStack.empty()) {\r\n        const currentVertex = vertexStack.pop()\r\n        if (currentVertex === endVertex) break\r\n        visitedVertices.add(currentVertex)\r\n        const incidentEdges = graph.getIncidentEdges(currentVertex)\r\n        incidentEdges.forEach(edge => {\r\n            edgesExplored.push(edge)\r\n            if (!visitedVertices.has(edge.second)) {\r\n                visitedVertices.add(edge.second)\r\n                vertexStack.push(edge.second)\r\n                parentMap[edge.second] = currentVertex\r\n            }\r\n        });\r\n    }\r\n    let current = endVertex\r\n    while (current !== startVertex) {\r\n        path.push(current)\r\n        current = parentMap[current]\r\n    }\r\n    path.push(startVertex)\r\n    return {path: path.reverse(), edgesExplored: edgesExplored}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Partition from './Partition'\r\nimport Graph from '../models/Graph'\r\n\r\nexport default function boruvka(graph) {\r\n    let partition = new Partition(graph.vertexCount)\r\n    let maze = new Graph(graph.width, graph.height)\r\n    let mst = []\r\n    let treeCount = graph.vertexCount\r\n    let cheapest = new Array(graph.vertexCount)\r\n    while (treeCount > 1) {\r\n        for (let i = 0; i < graph.vertexCount; i++) cheapest[i] = -1\r\n        for (let i = 0; i < graph.edges.length; i++) {\r\n            const edge = graph.edges[i]\r\n            if (!partition.doesMakeCycle(edge)) {\r\n                const firstRoot = partition.find(edge.first)\r\n                const secondRoot = partition.find(edge.second)\r\n                if (cheapest[firstRoot] === -1 || graph.edges[cheapest[firstRoot]].weight > edge.weight)\r\n                    cheapest[firstRoot] = i\r\n                if (cheapest[secondRoot] === -1 || graph.edges[cheapest[secondRoot]].weight > edge.weight)\r\n                    cheapest[secondRoot] = i\r\n            }\r\n        }\r\n        for (let vertex = 0; vertex < graph.vertexCount; vertex++) {\r\n            if (cheapest[vertex] !== -1) {\r\n                if (!partition.doesMakeCycle(graph.edges[cheapest[vertex]])) {\r\n                    maze.addEdge(graph.edges[cheapest[vertex]].first, graph.edges[cheapest[vertex]].second)\r\n                    mst.push(graph.edges[cheapest[vertex]])\r\n                    partition.addEdge(graph.edges[cheapest[vertex]])\r\n                    treeCount--\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {mst: mst, maze: maze}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Graph from \"../models/Graph\"\r\n\r\nclass PQEntry {\r\n    constructor(weight=9999999, vertex=9999999, edge=null) {\r\n        this.weight = weight\r\n        this.vertex = vertex\r\n        this.edge = edge\r\n    }\r\n}\r\n\r\nexport default function primJarnik(graph) {\r\n    let maze = new Graph(graph.width, graph.height)\r\n    let mst = []\r\n    let treeBounds = new Array(graph.vertexCount)\r\n    let priorityQueue = []\r\n    let entryMap = new Map()\r\n    for (let vertex = 0; vertex < graph.vertexCount; vertex++) {\r\n        treeBounds[vertex] = treeBounds.size === 0 ? 0 : 9999999\r\n        entryMap.set(vertex, new PQEntry(treeBounds[vertex], vertex, null))\r\n        priorityQueue.push(entryMap.get(vertex))\r\n    }\r\n    priorityQueue.sort((a, b) => b.weight - a.weight)\r\n    while (priorityQueue.length !== 0) {\r\n        const minElement = priorityQueue.pop()\r\n        if (minElement.edge !== null) {\r\n            maze.addEdge(minElement.edge.first, minElement.edge.second)\r\n            mst.push(minElement.edge)\r\n        }\r\n        const incidentEdges = graph.getIncidentEdges(minElement.vertex)\r\n        incidentEdges.forEach(edge => {\r\n            if (entryMap.has(edge.second) && edge.weight < treeBounds[edge.second]) {\r\n                treeBounds[edge.second] = edge.weight\r\n                entryMap.get(edge.second).weight = edge.weight\r\n                entryMap.get(edge.second).edge = edge\r\n                priorityQueue.sort((a, b) => b.weight - a.weight)\r\n            }\r\n        });\r\n        entryMap.delete(minElement.vertex)\r\n    }\r\n    return {mst: mst, maze: maze}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nexport default class Queue {\r\n    constructor() {\r\n        this.queue = []\r\n    }\r\n\r\n    empty() {\r\n        return (this.queue.length === 0)\r\n    }\r\n\r\n    enqueue(item) {\r\n        this.queue.push(item)\r\n    }\r\n\r\n    dequeue() {\r\n        return this.queue.shift()\r\n    }\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Queue from \"../models/Queue\"\r\n\r\nexport default function bfs(graph, startVertex, endVertex) {\r\n    let path = []\r\n    let edgesExplored = []\r\n    let vertexQueue = new Queue()\r\n    let visitedVertices = new Set()\r\n    visitedVertices.add(startVertex)\r\n    vertexQueue.enqueue(startVertex)\r\n    let parentMap = new Array(graph.vertexCount)\r\n    while (!vertexQueue.empty()) {\r\n        const currentVertex = vertexQueue.dequeue()\r\n        if (currentVertex === endVertex) break\r\n        const incidentEdges = graph.getIncidentEdges(currentVertex)\r\n        incidentEdges.forEach(edge => {\r\n            edgesExplored.push(edge)\r\n            if (!visitedVertices.has(edge.second)) {\r\n                visitedVertices.add(edge.second)\r\n                vertexQueue.enqueue(edge.second)\r\n                parentMap[edge.second] = currentVertex\r\n            }\r\n        });\r\n    }\r\n    let current = endVertex\r\n    while (current !== startVertex) {\r\n        path.push(current)\r\n        current = parentMap[current]\r\n    }\r\n    path.push(startVertex)\r\n    return {path: path.reverse(), edgesExplored: edgesExplored}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nclass HeapEntry {\r\n    constructor(vertex=999999, distance=999999) {\r\n        this.vertex = vertex\r\n        this.distance = distance\r\n    }\r\n}\r\n\r\nexport default function dijkstra(graph, startVertex, endVertex) {\r\n    let path = []\r\n    let edgesExplored = []\r\n    let distances = new Array(graph.vertexCount)\r\n    for (let i = 0; i < graph.vertexCount; i++) {\r\n        distances[i] = 999999\r\n    }\r\n    let entryMap = new Map()\r\n    let visitedVertices = new Set()\r\n    let unvisitedNodes = []\r\n    let parentMap = new Array(graph.vertexCount)\r\n    distances[startVertex] = 0\r\n    entryMap.set(startVertex, new HeapEntry(startVertex, 0))\r\n    unvisitedNodes.push(entryMap.get(startVertex))\r\n    while (unvisitedNodes.length !== 0) {\r\n        const minVertex = unvisitedNodes.pop()\r\n        const currentVertex = minVertex.vertex\r\n        if (distances[currentVertex] === 999999 || currentVertex === endVertex) break\r\n        const incidentEdges = graph.getIncidentEdges(currentVertex)\r\n        incidentEdges.forEach(edge => {\r\n            const neighbour = edge.second\r\n            const newDistance = distances[currentVertex] + edge.weight\r\n            if (!visitedVertices.has(neighbour) && newDistance < distances[neighbour]) {\r\n                edgesExplored.push(edge)\r\n                if (!entryMap.has(neighbour)) {\r\n                    entryMap.set(neighbour, new HeapEntry(neighbour, newDistance))\r\n                    unvisitedNodes.push(entryMap.get(neighbour))\r\n                } else {\r\n                    entryMap.get(neighbour).distance = newDistance\r\n                }\r\n                unvisitedNodes.sort((a, b) => b.distance - a.distance)\r\n                distances[neighbour] = newDistance\r\n                parentMap[neighbour] = currentVertex\r\n            }\r\n        });\r\n        visitedVertices.add(currentVertex)\r\n        \r\n    }\r\n    let current = endVertex\r\n    while (current !== startVertex) {\r\n        path.push(current)\r\n        current = parentMap[current]\r\n    }\r\n    path.push(startVertex)\r\n    return {path: path.reverse(), edgesExplored: edgesExplored}\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nclass HeapEntry {\r\n    constructor(vertex=999999, distance=999999) {\r\n        this.vertex = vertex\r\n        this.distance = distance\r\n    }\r\n}\r\n\r\nexport default function astar(graph, startVertex, endVertex) {\r\n    let path = []\r\n    let edgesExplored = []\r\n    let distances = new Array(graph.vertexCount)\r\n    for (let i = 0; i < graph.vertexCount; i++) {\r\n        distances[i] = 999999\r\n    }\r\n    let entryMap = new Map()\r\n    let visitedVertices = new Set()\r\n    let unvisitedNodes = []\r\n    let parentMap = new Array(graph.vertexCount)\r\n    distances[startVertex] = 0\r\n    entryMap.set(startVertex, new HeapEntry(startVertex, 0))\r\n    unvisitedNodes.push(entryMap.get(startVertex))\r\n    while (unvisitedNodes.length !== 0) {\r\n        const minVertex = unvisitedNodes.pop()\r\n        const currentVertex = minVertex.vertex\r\n        if (distances[currentVertex] === 999999 || currentVertex === endVertex) break\r\n        const incidentEdges = graph.getIncidentEdges(currentVertex)\r\n        incidentEdges.forEach(edge => {\r\n            const neighbour = edge.second\r\n            const newDistance = distances[currentVertex] + edge.weight\r\n            const remainingDistance = manhattanDistance(graph, currentVertex, endVertex)\r\n            if (!visitedVertices.has(neighbour) && newDistance < distances[neighbour]) {\r\n                edgesExplored.push(edge)\r\n                if (!entryMap.has(neighbour)) {\r\n                    entryMap.set(neighbour, new HeapEntry(neighbour, newDistance + remainingDistance))\r\n                    unvisitedNodes.push(entryMap.get(neighbour))\r\n                } else {\r\n                    entryMap.get(neighbour).distance = newDistance + remainingDistance\r\n                }\r\n                unvisitedNodes.sort((a, b) => b.distance - a.distance)\r\n                distances[neighbour] = newDistance\r\n                parentMap[neighbour] = currentVertex\r\n            }\r\n        });\r\n        visitedVertices.add(currentVertex)\r\n        \r\n    }\r\n    let current = endVertex\r\n    while (current !== startVertex) {\r\n        path.push(current)\r\n        current = parentMap[current]\r\n    }\r\n    path.push(startVertex)\r\n    return {path: path.reverse(), edgesExplored: edgesExplored}\r\n}\r\n\r\nfunction manhattanDistance(graph, first, second) {\r\n    const firstPosition = getVertexPosition(graph, first)\r\n    const secondPosition = getVertexPosition(graph, second)\r\n    return Math.abs(firstPosition.row - secondPosition.row) + Math.abs(firstPosition.column - secondPosition.column)\r\n}\r\n\r\nfunction getVertexPosition(graph, vertex) {\r\n    return {\r\n        row: Math.floor(vertex / graph.width),\r\n        column: vertex % graph.width\r\n    }\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport Queue from '../models/Queue'\r\n\r\nexport default function bidirectionalSearch(graph, startVertex, endVertex) {\r\n    let edgesExplored = []\r\n    let startVisited = new Array(graph.vertexCount)\r\n    let endVisited = new Array(graph.vertexCount)\r\n    let startParent = new Array(graph.vertexCount)\r\n    let endParent = new Array(graph.vertexCount)\r\n    const startQueue = new Queue()\r\n    const endQueue = new Queue()\r\n    let intersect = -1\r\n    for (let i = 0; i < graph.vertexCount; i++) {\r\n        startVisited[i] = false\r\n        endVisited[i] = false\r\n    }\r\n    startQueue.enqueue(startVertex)\r\n    startVisited[startVertex] = true\r\n    startParent[startVertex] = -1\r\n    endQueue.enqueue(endVertex)\r\n    endVisited[endVertex] = true\r\n    endParent[endVertex] = -1\r\n    while (!startQueue.empty() && !endQueue.empty()) {\r\n        bfsHelper(startQueue, startVisited, startParent, graph, edgesExplored)\r\n        bfsHelper(endQueue, endVisited, endParent, graph, edgesExplored)\r\n        intersect = hasIntersectingNode(startVisited, endVisited)\r\n        if (intersect !== -1) {\r\n            return buildPath(startParent, endParent, startVertex, endVertex, intersect, edgesExplored)\r\n        }\r\n    }\r\n}\r\n\r\nfunction buildPath(startParent, endParent, startVertex, endVertex, intersect, edgesExplored) {\r\n    let path = []\r\n    path.push(intersect)\r\n    let current = intersect\r\n    while (current !== startVertex) {\r\n        path.push(startParent[current])\r\n        current = startParent[current]\r\n    }\r\n    path = path.reverse()\r\n    current = intersect\r\n    while (current !== endVertex) {\r\n        path.push(endParent[current])\r\n        current = endParent[current]\r\n    }\r\n    return {path: path, edgesExplored: edgesExplored}\r\n}\r\n\r\nfunction bfsHelper(queue, visited, parent, graph, edgesExplored) {\r\n    const currentVertex = queue.dequeue()\r\n    const incidentEdges = graph.getIncidentEdges(currentVertex)\r\n    incidentEdges.forEach(edge => {\r\n        if (!visited[edge.second]) {\r\n            edgesExplored.push(edge)\r\n            parent[edge.second] = currentVertex\r\n            visited[edge.second] = true\r\n            queue.enqueue(edge.second)\r\n        }\r\n    });\r\n}\r\n\r\nfunction hasIntersectingNode(startVisited, endVisited) {\r\n    for (let i = 0; i < startVisited.length; i++) {\r\n        if (startVisited[i] && endVisited[i]) return i;\r\n    }\r\n    return -1\r\n}","/*\r\nMaze generation and solving using graph algorithms\r\nCopyright (C) 2020 Dušan Erdeljan\r\n\r\nThis file is part of maze-solver\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\r\n*/\r\n\r\nimport React, { Component } from 'react'\r\nimport Graph from '../models/Graph'\r\nimport Node from './Node.jsx'\r\nimport Edge from './Edge.jsx'\r\nimport kruskal from '../mst/Kruskal'\r\nimport './Canvas.css'\r\nimport dfs from '../pathfinding/DFS'\r\nimport boruvka from '../mst/Boruvka'\r\nimport primJarnik from '../mst/PrimJarnik'\r\nimport bfs from '../pathfinding/BFS'\r\nimport dijkstra from '../pathfinding/Dijkstra'\r\nimport astar from '../pathfinding/AStar'\r\nimport bidirectionalSearch from '../pathfinding/BidirectionalSearch'\r\n\r\nexport class Canvas extends Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.width = 50\r\n        this.height = 25\r\n        this.graph = null\r\n        this.maze = null\r\n        this.mazeGenerationFunctions = new Map()\r\n        this.mazeGenerationFunctions.set(\"kruskal\", kruskal)\r\n        this.mazeGenerationFunctions.set(\"prim-jarnik\", primJarnik)\r\n        this.mazeGenerationFunctions.set(\"boruvka\", boruvka)\r\n        this.mazeSolvingFunctions = new Map()\r\n        this.mazeGenerationFunctions.set(\"dfs\", dfs)\r\n        this.mazeGenerationFunctions.set(\"bfs\", bfs)\r\n        this.mazeGenerationFunctions.set(\"dijkstra\", dijkstra)\r\n        this.mazeGenerationFunctions.set(\"astar\", astar)\r\n        this.mazeGenerationFunctions.set(\"bidirectionalSearch\", bidirectionalSearch)\r\n        this.startPosX = 0.1 * window.innerWidth\r\n        this.startPosY = 0.15 * window.innerHeight\r\n        this.generatedMaze = false\r\n        this.state = {\r\n            mstEdges: [],\r\n            startVertex: -1,\r\n            endVertex: -1,\r\n            nodeDimensions: 0.8 * window.innerWidth / (2*this.width-1),\r\n            errorMessage: \"\"\r\n        }\r\n        this.generateMaze = this.generateMaze.bind(this)\r\n        this.solveMaze = this.solveMaze.bind(this)\r\n        this.mazeClickHandler = this.mazeClickHandler.bind(this)\r\n        this.mazeSizeChanged = this.mazeSizeChanged.bind(this)\r\n        this.updateNodeDimensions = this.updateNodeDimensions.bind(this)\r\n    }\r\n\r\n    updateNodeDimensions() {\r\n        this.startPosX = 0.1 * window.innerWidth\r\n        this.startPosY = 0.15 * window.innerHeight\r\n        this.setState(prevState => ({\r\n            ...prevState,\r\n            nodeDimensions: 0.8 * window.innerWidth / (2*this.width-1)\r\n        }))\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.initState()\r\n        window.addEventListener('resize', this.updateNodeDimensions)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.updateNodeDimensions)\r\n    }\r\n\r\n    generateMaze() {\r\n        this.graph = Graph.buildGraph(this.width, this.height)\r\n        this._generateButton.disabled = true\r\n        this._solveButton.disabled = true\r\n        this._sizeSlider.disabled = true\r\n        this.generatedMaze = false\r\n        this.setState(prevState => ({\r\n            mstEdges: [],\r\n            startVertex: -1,\r\n            endVertex: -1,\r\n            errorMessage: \"\"\r\n        }))\r\n        const {mst, maze} = this.mazeGenerationFunctions.get(this._generationSelect.value)(this.graph)\r\n        this.maze = maze\r\n        for (let i = 0; i < mst.length; i++) {\r\n            setTimeout(() => {\r\n                this.setState(prevState => ({\r\n                    ...prevState, \r\n                    mstEdges: mst.slice(0, i+1)\r\n                }))\r\n            }, i*5);\r\n        }\r\n        setTimeout(() => {\r\n            this.generatedMaze = true\r\n            this._generateButton.disabled = false\r\n            this._solveButton.disabled = false\r\n            this._sizeSlider.disabled = false\r\n            this.setState(prevState=> ({\r\n                ...prevState,\r\n                startVertex: 0,\r\n                endVertex: this.maze.vertexCount-1\r\n            }))\r\n        }, mst.length*5);\r\n    }\r\n\r\n    displayPath(path) {\r\n        for (let i = 1; i < path.length; i++) {\r\n            setTimeout(() => {\r\n                const edge = {first: path[i], second: path[i-1]}\r\n                const minVertex = Math.min(edge.first, edge.second)\r\n                const maxVertex = Math.max(edge.first, edge.second)\r\n                let edgeStyle = document.getElementById(`edge-${minVertex}-${maxVertex}`).style\r\n                edgeStyle.backgroundColor = \"#4fb813\"\r\n                edgeStyle.zIndex = 600\r\n                edgeStyle.animation = \"path\"\r\n                edgeStyle.animationDuration = \"0.5s\"\r\n\r\n            }, i*50);\r\n        }\r\n        setTimeout(() => {\r\n            this._generateButton.disabled = false\r\n            this._solveButton.disabled = false\r\n            this._sizeSlider.disabled = false\r\n            this.maze = null\r\n        }, path.length*50);\r\n    }\r\n\r\n    checkStartEndVertex() {\r\n        if (this.maze == null) return false\r\n        if (this.state.startVertex === -1) {\r\n            this.setState(prevState => ({\r\n                ...prevState,\r\n                errorMessage: \"Start vertex is not set. Click on the desired location on the board to set start vertex.\"\r\n            }))\r\n            return false\r\n        }\r\n        if (this.state.endVertex === -1) {\r\n            this.setState(prevState => ({\r\n                ...prevState,\r\n                errorMessage: \"End vertex is not set. Shift+Click on the desired location on the board to set end vertex.\"\r\n            }))\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    solveMaze() {\r\n        if (!this.checkStartEndVertex())\r\n            return\r\n        this._generateButton.disabled = true\r\n        this._solveButton.disabled = true\r\n        this.generatedMaze = false\r\n        this._sizeSlider.disabled = true\r\n        const {path, edgesExplored} = this.mazeGenerationFunctions.get(this._solvingSelect.value)(this.maze, this.state.startVertex, this.state.endVertex)\r\n        this.setState(prevState => ({\r\n            ...prevState,\r\n            errorMessage: \"\"\r\n        }))\r\n        for (let i = 0; i <= edgesExplored.length; i++) {\r\n            if (i === edgesExplored.length) {\r\n                setTimeout(() => {\r\n                    this.displayPath(path)\r\n                }, i*20);\r\n            } else {\r\n                setTimeout(() => {\r\n                    const edge = edgesExplored[i]\r\n                    const minVertex = Math.min(edge.first, edge.second)\r\n                    const maxVertex = Math.max(edge.first, edge.second)\r\n                    let edgeStyle = document.getElementById(`edge-${minVertex}-${maxVertex}`).style\r\n                    edgeStyle.backgroundColor = \"#df6f3f\"\r\n                    edgeStyle.zIndex = 500\r\n                    edgeStyle.animation = \"solving\"\r\n                    edgeStyle.animationDuration = \"0.5s\"\r\n                }, i*20);\r\n            }\r\n        }\r\n    }\r\n\r\n    initState() {\r\n        this.graph = Graph.buildGraph(this.width, this.height)\r\n        const {mst, maze} = kruskal(this.graph)\r\n        this.maze = maze\r\n        this.setState({\r\n            mstEdges: mst,\r\n            startVertex: 0,\r\n            endVertex: maze.vertexCount-1,\r\n            errorMessage: \"\"\r\n        })\r\n        this.generatedMaze = true\r\n    }\r\n\r\n    mazeSizeChanged(event) {\r\n        const testWidth = parseInt(this._sizeSlider.value)\r\n        if (testWidth === this.width) return\r\n        this.width = testWidth\r\n        this.height = Math.floor(this.width / 2)\r\n        this.setState(prevState => ({\r\n            mstEdges: [],\r\n            startVertex: -1,\r\n            endVertex: -1,\r\n            errorMessage: \"\"\r\n        }), () => this.initState())\r\n    }\r\n\r\n    mazeClickHandler(event) {\r\n        if (!this.generatedMaze || !(event.nativeEvent.target)) return\r\n        const nodeDimensions = 0.8 * window.innerWidth / (2*this.width-1)\r\n        const column = Math.floor((event.nativeEvent.x - this.startPosX)/nodeDimensions)\r\n        const row = Math.floor((event.nativeEvent.y - this.startPosY)/nodeDimensions)\r\n        if (column % 2 === 1 || row % 2 === 1) return\r\n        const vertexRow = Math.floor((row+1)/2)\r\n        const vertexColumn = Math.floor((column+1)/2)\r\n        const vertex = vertexRow*this.width + vertexColumn\r\n        if (event.shiftKey && this.state.startVertex !== vertex) {\r\n            this.setState(prevState => ({\r\n                mstEdges: prevState.mstEdges,\r\n                startVertex: prevState.startVertex,\r\n                endVertex: prevState.endVertex === vertex ? -1 : vertex\r\n            }))\r\n        } else if (this.state.endVertex !== vertex) {\r\n            this.setState(prevState => ({\r\n                mstEdges: prevState.mstEdges,\r\n                startVertex: prevState.startVertex === vertex ? -1 : vertex,\r\n                endVertex: prevState.endVertex\r\n            }))\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const nodeDimensions = this.state.nodeDimensions\r\n        const edges = this.state.mstEdges.map((edge, index) => {\r\n            const minVertex = Math.min(edge.first, edge.second)\r\n            const pos = {\r\n                top: this.startPosY + 2*(Math.floor(minVertex / this.width)) * nodeDimensions, \r\n                left: this.startPosX + 2*(minVertex % this.width) * nodeDimensions\r\n            }\r\n            return <div key={index}><Edge edge={edge} position={pos} dimension={nodeDimensions}/></div>\r\n        })\r\n        const nodes = []\r\n        if (this.state.startVertex !== -1) {\r\n            const pos = {\r\n                top: this.startPosY + 2*(Math.floor(this.state.startVertex / this.width)) * nodeDimensions, \r\n                left: this.startPosX + 2*(this.state.startVertex % this.width) * nodeDimensions\r\n            }\r\n            nodes.push(<div key={this.state.mstEdges.length}><Node type=\"start\" position={pos} dimension={nodeDimensions} /></div>)\r\n        }\r\n        if (this.state.endVertex !== -1) {\r\n            const pos = {\r\n                top: this.startPosY + 2*(Math.floor(this.state.endVertex / this.width)) * nodeDimensions, \r\n                left: this.startPosX + 2*(this.state.endVertex % this.width) * nodeDimensions\r\n            }\r\n            nodes.push(<div key={this.state.mstEdges.length+1}><Node type=\"end\" position={pos} dimension={nodeDimensions} /></div>)\r\n        }\r\n        return (\r\n            <div>\r\n                <div className=\"options\">\r\n                    <label htmlFor=\"mst\" style={{color: \"white\"}}>Select maze generation algorithm: </label>\r\n                    <select id=\"mst\" ref={ref => {this._generationSelect = ref}}>\r\n                        <option value=\"kruskal\">Kruskal</option>\r\n                        <option value=\"prim-jarnik\">Prim-Jarnik</option>\r\n                        <option value=\"boruvka\">Boruvka</option>\r\n                    </select>\r\n                    <button onClick={this.generateMaze} ref={ref => {this._generateButton = ref}}>\r\n                        Generate maze\r\n                    </button>\r\n                    <label htmlFor=\"solver\" style={{color: \"white\"}}>Select maze solving algorithm: </label>\r\n                    <select id=\"solver\" ref={ref => {this._solvingSelect = ref}}>\r\n                        <option value=\"dfs\">DFS</option>\r\n                        <option value=\"bfs\">BFS</option>\r\n                        <option value=\"dijkstra\">Dijkstra</option>\r\n                        <option value=\"astar\">A*</option>\r\n                        <option value=\"bidirectionalSearch\">Bidirectional search</option>\r\n                    </select>\r\n                    <button onClick={this.solveMaze} ref={ref => {this._solveButton = ref}}>\r\n                        Solve maze\r\n                    </button>\r\n                    <label htmlFor=\"size-slider\" style={{color: \"white\"}}>Select maze size: </label>\r\n                    <input id=\"size-slider\" className=\"slider\" type=\"range\" min={20} max={100} step={2} onChange={this.mazeSizeChanged} ref={ref => {this._sizeSlider = ref}}></input>\r\n                </div>\r\n                <div className=\"error\">\r\n                    {this.state.errorMessage}\r\n                </div>\r\n                <div className=\"canvas\" onClick={this.mazeClickHandler}>\r\n                    {edges}\r\n                    {nodes}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Canvas\r\n","/*\nMaze generation and solving using graph algorithms\nCopyright (C) 2020 Dušan Erdeljan\n\nThis file is part of maze-solver\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport React from 'react';\nimport './App.css';\nimport Canvas from './components/Canvas.jsx'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Canvas/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}